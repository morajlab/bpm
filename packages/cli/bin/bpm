#!/usr/bin/env bash

GLOBAL_BASH_MODULES_PATH=$HOME/.bash_modules
declare -A PACKAGE_INFO_SCHEMA=(
  # ["KEY"]='(["type"]="<dict|array|string>" ["required"]=<false|true>)'
  ["NAME"]='(["type"]="string" ["required"]=true)'
  ["VERSION"]='(["type"]="string" ["required"]=true)'
  ["DESCRIPTION"]='(["type"]="string" ["required"]=false)'
  ["KEYWORDS"]='(["type"]="array" ["required"]=false)'
  ["DEPENDENCIES"]='(["type"]="dict" ["required"]=false)'
  ["DEVDEPENDENCIES"]='(["type"]="dict" ["required"]=false)'
  ["LICENSE"]='(["type"]="string" ["required"]=false)'
  ["AUTHOR"]='(["type"]="dict" ["required"]=false)'
  ["REPOSITORY"]='(["type"]="string" ["required"]=false)'
)

# Private functions
__find_bash_modules() {
  local root_path=
  local current_path=$(pwd)
  local is_root=false

  while ! $is_root; do
    if [ $current_path = / ]; then
      echo 1
      exit 1
    fi

    if [ -d "$current_path/bash_modules" ]; then
      root_path="$current_path/bash_modules"
      is_root=true
    fi

    current_path=$(dirname $current_path)
  done

  echo "$root_path"
}

__bash_module_installed() {
  if [ -z "$1" ] || \
     [ -z "$(ls -A $1/bin/ 2> /dev/null)" ]; then
    echo ">>> ERROR  :: bash modules are not installed."
    exit 1
  fi

  if [ ! -z "$2" ] && [ ! -f "$1/bin/$2" ]; then
    echo ">>> ERROR  : module '$2' is not installed."
    exit 1
  fi
}

__normalize_package_info() {
  local package_info=${1//\[/\\\[}
  package_info=${package_info//\]/\\\]}

  echo "$package_info"
}

__validate_package_info() {
  eval "$1"

  for key in "${!PACKAGE_INFO_SCHEMA[@]}"; do
    declare -A schema_key_dict="${PACKAGE_INFO_SCHEMA[$key]}"
    local value=
    local errors=()

    case "${schema_key_dict[type]^^}" in
      "STRING")
        value="${!key}"

        if [ "${schema_key_dict[required]^^}" == "TRUE" ] && \
           [ -z "$value" ]; then
          errors+=("value for key '$key' is required.")
        fi
      ;;
      "ARRAY")
        printf -v arrayeval 'value=$(echo "${%s[@]}")' "$key"
        eval "$arrayeval"

        if [ "${schema_key_dict[required]^^}" == "TRUE" ] && \
           [ -z "$value" ]; then
          errors+=("value for key '$key' is required.")
        fi
      ;;
      "DICT")
        declare -A tdict
        local dicteval=$(cat <<- 'EOF'
for i in "${%s[@]}"; do
  local _key=$(echo "$i" | cut -d '=' -f 1)
  local _value=$(echo "$i" | cut -d '=' -f 2)

  eval "tdict$_key=\"$_value\""
done
EOF
        )
        dicteval=${dicteval//\%s/"$key"}

        eval "$dicteval"

        if [ "${schema_key_dict[required]^^}" == "TRUE" ] && \
           [ -z "$tdict" ]; then
          errors+=("value for key '$key' is required.")
        fi
      ;;
    esac

    if [ ! -z "$errors" ]; then
      for e in "${errors[@]}"; do
        echo ">>> ERROR  :: $e"
      done

      exit 1
    fi
  done
}

# Public functions
install() {
  local bin_path=$(pwd)/bash_modules/bin
  local packages=()

  shift

  while [ "$#" -gt 0 ]; do
    case "${1^^}" in
      "--GLOBAL" | "-G")
        bin_path=$GLOBAL_BASH_MODULES_PATH/bin

        shift
      ;;
      *)
        packages+=("$1")

        shift
      ;;
    esac
  done

  mkdir -p $bin_path

  for p in "${packages[@]}"; do
    local package_sh_url="https://raw.githubusercontent.com/morajlab/bash-scripts/master/packages/$p/package.sh"
    local package_info="$(curl -fsSL $package_sh_url 2> /dev/null)"

    if [ -z "$package_info" ]; then
      echo ">>> ERROR  :: bash module '$p' doesn't exist."
      exit 1
    fi

    package_info=$(__normalize_package_info "$package_info")

    __validate_package_info "$package_info"

    # while IFS= read -r line; do
    #   echo $line
    # done < <(
    #   eval "$package_info"

    #   for key in "${!PACKAGE_INFO_SCHEMA[@]}"; do
    #     # echo "$key => " "${!key}"
    #     schema_key_dict="${PACKAGE_INFO_SCHEMA[$key]}"
    #     echo ${schema_key_dict["type"]}
    #   done
    # )

    # (
    #  curl -Lfs -o $bin_path/$p \
    #  https://raw.githubusercontent.com/morajlab/bash-scripts/master/packages/$p/bin/$p || \
    #  echo ">>> ERROR  :: bash module '$p' doesn't exist."
    # )
  done

  # chmod u+x $bin_path -R
}
i() {
  install "$@"
}

import() {
  local bash_modules_paths=()
  local local_bash_modules=$(__find_bash_modules)

  if [ "$local_bash_modules" != "1" ]; then
    bash_modules_paths+=("$local_bash_modules")
  fi

  bash_modules_paths+=("$GLOBAL_BASH_MODULES_PATH")

  shift

  for p in "${bash_modules_paths[@]}"; do
    if [ -f "$p/bin/$1" ]; then
      echo "bash $p/bin/$1"
      exit 0
    fi
  done

  echo ">>> ERROR  :: module '$1' is not installed."
  exit 1
}

list() {
  local bash_modules=

  shift

  while [ "$#" -gt 0 ]; do
    case "${1^^}" in
      "--GLOBAL" | "-G")
        bash_modules=$GLOBAL_BASH_MODULES_PATH

        shift
      ;;
      *)
        shift
      ;;
    esac
  done

  if [ -z "$bash_modules" ]; then
    local local_bash_modules=$(__find_bash_modules)

    if [ "$local_bash_modules" != "1" ]; then
      bash_modules=$local_bash_modules
    fi
  fi

  __bash_module_installed "$bash_modules"

  for p in $(ls -A $bash_modules/bin/); do
    echo "- $p"
  done
}
l() {
  list "$@"
}

uninstall() {
  shift

  local bash_modules=
  local interactive=0
  local module="$1"

  shift

  while [ "$#" -gt 0 ]; do
    case "${1^^}" in
      "--GLOBAL" | "-G")
        bash_modules=$GLOBAL_BASH_MODULES_PATH

        shift
      ;;
      "--YES" | "-Y")
        interactive=1

        shift
      ;;
      *)
        shift
      ;;
    esac
  done

  if [ -z "$bash_modules" ]; then
    local local_bash_modules=$(__find_bash_modules)

    if [ "$local_bash_modules" != "1" ]; then
      bash_modules=$local_bash_modules
    fi
  fi

  __bash_module_installed "$bash_modules" "$module"

  rm -rf $bash_modules/bin/$module

  echo ">>> SUCCESS: module '$module' uninstalled."
}
u() {
  uninstall "$@"
}

if [[ $1 = __* ]] || [ "$(type -t $1)" != 'function' ]; then
  echo ">>> ERROR  :: argument '$1' is invalid."
  exit 1
fi

$1 "$@"
